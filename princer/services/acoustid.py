"""AcoustID fingerprinting service."""

import logging
from pathlib import Path
from typing import List, Optional, Dict, Any
from dataclasses import dataclass

import subprocess
import httpx
import json

from princer.core.config import Config


@dataclass
class FingerprintResult:
    """Result from AcoustID fingerprinting."""
    
    fingerprint: str
    duration: float
    acoustid_matches: List[Dict[str, Any]]
    error: Optional[str] = None


@dataclass 
class AcoustIDMatch:
    """A single AcoustID match with score and MBIDs."""
    
    acoustid: str
    score: float
    recording_ids: List[str]  # MusicBrainz recording IDs


class AcoustIDService:
    """Service for audio fingerprinting via AcoustID."""
    
    def __init__(self, config: Config):
        self.config = config
        self.api_key = config.api.acoustid_key
        self.logger = logging.getLogger(__name__)
        
        if not self.api_key:
            self.logger.warning("No AcoustID API key found. Set ACOUSTID_KEY environment variable.")
    
    def fingerprint_file(self, file_path: Path) -> FingerprintResult:
        """Generate fingerprint and query AcoustID for matches."""
        
        if not self.api_key:
            return FingerprintResult(
                fingerprint="",
                duration=0,
                acoustid_matches=[],
                error="No AcoustID API key configured"
            )
        
        try:
            # Generate fingerprint using fpcalc directly
            self.logger.info(f"Fingerprinting audio file: {file_path}")
            fingerprint, duration = self._generate_fingerprint(file_path)
            
            # Query AcoustID API for matches
            self.logger.info("Querying AcoustID API for matches...")
            matches = self._query_acoustid(fingerprint, duration)
            
            return FingerprintResult(
                fingerprint=fingerprint,
                duration=duration,
                acoustid_matches=matches
            )
            
        except Exception as e:
            self.logger.error(f"Error fingerprinting file {file_path}: {e}")
            return FingerprintResult(
                fingerprint="",
                duration=0,
                acoustid_matches=[],
                error=str(e)
            )
    
    def _generate_fingerprint(self, file_path: Path) -> tuple[str, float]:
        """Generate fingerprint using fpcalc command."""
        
        try:
            # Run fpcalc to generate fingerprint (without -raw for base64 encoded format)
            result = subprocess.run(
                ['fpcalc', str(file_path)],
                capture_output=True,
                text=True,
                check=True
            )
            
            # Parse fpcalc output
            lines = result.stdout.strip().split('\n')
            duration = 0
            fingerprint = ""
            
            for line in lines:
                if line.startswith('DURATION='):
                    duration = float(line.split('=')[1])
                elif line.startswith('FINGERPRINT='):
                    fingerprint = line.split('=')[1]
            
            if not fingerprint:
                raise ValueError("No fingerprint generated by fpcalc")
            
            return fingerprint, duration
            
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"fpcalc command failed: {e.stderr}")
        except Exception as e:
            raise RuntimeError(f"Error running fpcalc: {e}")
    
    def _query_acoustid(self, fingerprint: str, duration: float) -> List[Dict[str, Any]]:
        """Query AcoustID API with fingerprint."""
        
        try:
            # Prepare API request
            url = "https://api.acoustid.org/v2/lookup"
            data = {
                'client': self.api_key,
                'duration': int(duration),
                'fingerprint': fingerprint,
                'meta': 'recordings recordingids'  # Request both recordings and recordingids
            }
            
            # Make HTTP request
            with httpx.Client(timeout=30.0) as client:
                response = client.post(url, data=data)
                response.raise_for_status()
                
                result = response.json()
            
            # Parse results
            matches = []
            if result.get('status') == 'ok' and 'results' in result:
                for item in result['results']:
                    score = item.get('score', 0.0)
                    
                    # Extract recording info if available
                    if 'recordings' in item:
                        for recording in item['recordings']:
                            match_data = {
                                'score': score,
                                'recording_id': recording.get('id', 'N/A'),
                                'title': recording.get('title', 'Unknown'),
                                'artist': ', '.join([a.get('name', 'Unknown') for a in recording.get('artists', [])])
                            }
                            matches.append(match_data)
                    else:
                        # No detailed recording info, just the match
                        match_data = {
                            'score': score,
                            'recording_id': item.get('id', 'N/A'),
                            'title': 'Unknown',
                            'artist': 'Unknown'
                        }
                        matches.append(match_data)
            
            self.logger.info(f"Found {len(matches)} AcoustID matches")
            return matches
            
        except httpx.HTTPStatusError as e:
            self.logger.error(f"AcoustID API HTTP error: {e.response.status_code}")
            return []
        except Exception as e:
            self.logger.error(f"Error querying AcoustID API: {e}")
            return []
    
    def get_best_matches(self, result: FingerprintResult, min_score: float = 0.8) -> List[AcoustIDMatch]:
        """Filter and sort matches by score."""
        
        if result.error or not result.acoustid_matches:
            return []
        
        matches = []
        for match_data in result.acoustid_matches:
            score = match_data.get('score', 0.0)
            if score >= min_score:
                # Extract recording IDs (may be multiple per match)
                recording_id = match_data.get('recording_id')
                recording_ids = [recording_id] if recording_id else []
                
                match = AcoustIDMatch(
                    acoustid=result.fingerprint[:16],  # Short ID for display
                    score=score,
                    recording_ids=recording_ids
                )
                matches.append(match)
        
        # Sort by score descending
        matches.sort(key=lambda x: x.score, reverse=True)
        return matches
    
    def format_matches_summary(self, matches: List[AcoustIDMatch]) -> str:
        """Format matches for display."""
        
        if not matches:
            return "No high-confidence matches found"
        
        lines = []
        for i, match in enumerate(matches[:3], 1):  # Show top 3
            lines.append(
                f"{i}. Score: {match.score:.2f}, "
                f"Recording IDs: {len(match.recording_ids)}"
            )
        
        return "\n".join(lines)